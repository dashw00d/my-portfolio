---
title: "Migrating from ARQ to Motia: Building a Lightweight, Event-Driven Worker Framework for Scalable Scraping"
date: "2026-01-25"
excerpt: "We replaced ARQ with our custom event-driven framework Motia to gain control, clarity, and reliability in our scraping workflows."
tags: ["Python", "Background Jobs", "Distributed Systems", "Web Scraping", "System Design"]
author: "Ryan Dashwood"
---
## The ARQ Hangover: When Simplicity Becomes a Ceiling

ARQ was a solid starting point. For a while, it worked great—lightweight, asyncio-native, and easy to plug into our Vultr Scraper. But as our scraping workflows grew more dynamic, ARQ started showing its limits. What began as a simple queue system became a tangle of boilerplate, debugging headaches, and operational blind spots.

We were juggling dozens of job types: crawl triggers, relevance scoring, schema inference, retries with backoff, and dynamic job chaining. ARQ’s function-based job registration meant we ended up with a sprawling `jobs.py` file that felt more like a graveyard of decorators than a maintainable codebase. Worse, debugging failed jobs meant digging through Redis, reconstructing contexts from serialized payloads, and guessing at state. There was no visibility—just timeouts and silent failures.

And don’t get me started on deployment. Scaling workers meant managing multiple ARQ processes, each polling Redis independently. We hit race conditions, duplicate processing, and inconsistent retry behavior. We needed more control—not less abstraction.

## Enter Motia: Event-Driven, Lean, and Built for Observability

So we built Motia: a lightweight, event-driven worker framework tailored to our scraping use case. The goal wasn’t to reinvent the wheel, but to build a *better-fitting* one.

Motia’s core idea is simple: jobs are events, and workers react to them. Instead of polling Redis for functions to call, Motia uses a Postgres-backed claim-loop queue where each job is a row with a status (`pending`, `claimed`, `processing`, `done`, `failed`). Workers pull jobs atomically using `SELECT ... FOR UPDATE`, ensuring no two workers ever process the same job.

Here’s how it works:

1. A job is inserted into the `jobs` table with `status = 'pending'`.
2. A worker issues `BEGIN; SELECT * FROM jobs WHERE status = 'pending' ORDER BY priority, created_at FOR UPDATE SKIP LOCKED LIMIT 1;`—grabbing and locking the job in one atomic step.
3. The job status is updated to `claimed`, and the worker begins processing.

This claim-loop pattern eliminated race conditions and gave us full auditability. Every job’s lifecycle is logged, timestamped, and queryable. No more guessing.

But the real win was the event-driven architecture. In Motia, jobs emit events (`job_started`, `job_failed`, `job_completed`) that can trigger downstream actions—like kicking off a relevance analysis after a crawl finishes. We replaced brittle job chaining with composable event handlers:

```python
@on_event("job_completed")
async def trigger_relevance_analysis(event: JobEvent):
    if event.job_type == "crawl":
        await enqueue_job("relevance_score", payload={"crawl_id": event.result_id})
```

This made workflows declarative, testable, and easy to extend. No more embedding queue logic inside job functions.

## Developer Experience: From Opaque to Obvious

The migration wasn’t just about performance—it was about sanity.

With ARQ, every deployment felt like rolling the dice. With Motia, we gained confidence. Failed jobs? They’re logged with full context in Postgres. Need to replay one? Just reset its status. Want to pause processing? Update the worker poll interval via config—no Redis flushes or container restarts.

We also cut operational overhead. No more managing Redis memory, tuning retry backoffs in code, or debugging serialization errors. Since job state lives in Postgres—the same DB as our business data—we can run analytics, build dashboards, and audit processing all in one place.

And deployment? Now we scale workers by simply spinning up more containers, each running a Motia worker loop. They auto-discover jobs, claim them safely, and report status back. Zero coordination needed.

The final push—production hardening Motia—wrapped up today. Circuit breakers, retry budgets, graceful shutdowns, and structured logging are all in place. The system has been running stable for weeks, processing thousands of jobs daily with near-zero intervention.

## Why Build When You Can Borrow?

I get it: "Don’t build your own queue." And usually, I agree. But sometimes, the off-the-shelf solution solves 80% of your problem—and makes the other 20% a nightmare.

Motia isn’t for everyone. If you’re running simple, fire-and-forget jobs, stick with ARQ or Celery. But if you need fine-grained control, strong consistency, and full observability in a high-throughput, dynamic workflow—especially in scraping or data pipelines—consider rolling something lean and purpose-built.

In our case, ditching ARQ for Motia didn’t just fix bugs—it made the system *understandable*. We went from debugging in the dark to watching a live circuit board. And that’s worth rebuilding for.
