---
title: "How We Enabled Early Form Submissions in a Multi-Step Quote Request with React and Alpine.js"
date: "2024-08-16"
excerpt: "We let users submit a multi-step quote form early without sacrificing data integrity—here’s how we pulled it off with React and Alpine.js."
tags: ["React", "Alpine.js", "Laravel", "form optimization", "user experience"]
author: "Ryan Dashwood"
---
## The Problem: Long Forms, Short Attention Spans

We’ve all been there—halfway through a 5-step quote form, you’ve already given enough info, but the system insists you keep going. At AustinsElite, our Laravel 12-powered platform guides users through a detailed multi-step quote request to ensure we collect everything needed for accurate estimates. But analytics showed a clear pattern: high drop-off after step two.

Users weren’t quitting because they lost interest—they were frustrated. Many had already provided core details (project type, contact info, basic scope) by step two, yet had to trudge through three more screens just to submit. We knew we had enough data to act, but the form wouldn’t let them jump the gun. That friction was costing us conversions.

So we asked: *What if users could submit early—once they’ve given the essentials—without compromising data quality or backend expectations?*

## Building the Solution: React State Meets Alpine.js Interactivity

The form itself is built with React on the frontend, integrated into a Laravel 12 application, with Alpine.js sprinkled in for lightweight interactivity—especially on dynamic UI elements that don’t need full React re-renders.

Our strategy had two parts: **logic** and **feedback**.

First, we used React state to track which required fields for early submission were complete. We defined a minimal viable dataset—name, email, project type, and scope description—and added a `canSubmitEarly` flag that updated dynamically as users filled out fields.

```javascript
const [canSubmitEarly, setCanSubmitEarly] = useState(false);

useEffect(() => {
  const isReady = !!formData.name && 
                !!formData.email && 
                !!formData.projectType && 
                formData.scope.length > 20;
  setCanSubmitEarly(isReady);
}, [formData]);
```

This flag powered a "Submit Now" button that appeared conditionally at the bottom of step two. But we didn’t just want to show a button—we wanted to make it feel responsive, instant, and safe.

That’s where Alpine.js came in. While the main form state lived in React, we used Alpine to manage the button’s visual state—loading spinners, hover effects, and real-time enable/disable toggles—without adding complexity to the React component tree.

```html
<button
  x-bind:disabled="!@js($canSubmitEarly)"
  x-text="@js($canSubmitEarly) ? 'Submit Now' : 'Complete More Steps'"
  @click="submitEarly()"
  class="btn btn-primary"
  x-bind:class="{ 'opacity-50 cursor-not-allowed': loading }"
>
</button>
```

Alpine synced with backend-exposed flags (via Laravel Blade props) and reacted instantly to user input, giving a snappier feel than waiting for React to re-render. It was the perfect glue for progressive enhancement.

## Preventing Chaos: Duplicates, Partial Data, and State Sync

Letting users submit early sounds simple—until you consider the edge cases.

What if someone spams the button? What if they go back and edit? And how do we ensure the backend only processes the quote once, even if the form technically spans multiple steps?

We tackled this in layers.

First, **duplicate protection**: on submission, we set a `submissionLocked` flag in React *and* triggered Alpine to disable the button and show a loading spinner. This dual-layer lock—both in React state and DOM-level with Alpine—ensured no double-clicks slipped through, even on slow connections.

```javascript
const handleSubmitEarly = async () => {
  if (submissionLocked) return;

  setSubmissionLocked(true);
  // Send minimal payload
  await fetch('/api/quote/submit-early', { method: 'POST', body: JSON.stringify(formData) });
  // Redirect or show confirmation
};
```

Second, **partial data handling**: the Laravel backend was updated to accept early submissions as a valid state. Instead of rejecting incomplete step data, it marked the quote as "prematurely submitted" and triggered a follow-up email to gather missing details post-submission. This kept the funnel moving without sacrificing backend integrity.

Finally, **state sync**: since parts of the form lived in Livewire components (for real-time validation and conditional fields), we had to ensure React, Alpine, and Livewire weren’t working at cross purposes. We used custom events (`earlySubmissionInitiated`) to notify Livewire components to freeze their inputs and prevent async updates after submission.

## The Result? Faster Conversions, Happier Users

Since deploying early submission on August 16, we’ve seen a 22% increase in completed quote requests—and a noticeable drop in support tickets asking, "Can I just send what I have?"

More importantly, users feel heard. They’re not forced into a rigid flow; they can move at their own pace. And because we’re still collecting essential data upfront, our sales team hasn’t had to compromise on lead quality.

This wasn’t about cutting corners. It was about respecting user intent. By combining React’s state power with Alpine.js’s lightweight reactivity—and anchoring it all in a robust Laravel 12 backend—we built a form that’s smart enough to know when to let go.

Sometimes, the best UX isn’t more steps. It’s knowing when to say: *You’re ready.*
